%YAML 1.2
---
# todo(jbr) punctuation.accessor for :: . ->
# todo(jbr) entity.name.function when defined, variable.function when invoked
# todo(jbr) do we need anything for the * or & symbols in variables?
# todo(jbr) forward decls
# note to self - lookaheads don't consume, captures do
name: C/C++ (better)
file_extensions: [h, c, hpp, cpp, inl]
scope: source.c++
variables:
  name: '[A-Za-z_]\w*'
  type_name: '[A-Za-z_][\w:]*' # types can have :: in for example std::string
contexts:
  main:
    - include: common

    - match: '#'
      push: preprocessor

    - match: \bnamespace\b
      scope: keyword.control.c++
      set: namespace_name

    - match: \bconst\b
      scope: storage.modifier.c++
      set:
        - match: \b(static|inline|const|extern)\b
          scope: storage.modifier.c++
        - match: \b{{type_name}}\b
          scope: storage.type.c++
          set: possible_const_variable_or_function

    - match: \b(static|inline|const|extern)\b
      scope: storage.modifier.c++

    - match: \b{{type_name}}\b
      scope: storage.type.c++
      set: variable_or_function

  common:
    # Strings begin and end with quotes, and use backslashes as an escape
    # character
    - match: '"'
      scope: punctuation.definition.string.begin.c++
      push: double_quoted_string

    # Comments begin with a '//' and finish at the end of the line
    - match: '//'
      scope: punctuation.definition.comment.c++
      push: line_comment

    # Block comments
    - match: '/\*'
      scope: punctuation.definition.comment.c++
      push: block_comment

    # Numbers
    - match: '\b[-]?[0-9]+[.]?[0-9]*[f]?\b'
      scope: constant.numeric.c++

    # Nullptr
    - match: \b(nullptr|true|false)\b
      scope: constant.language.c++

  double_quoted_string:
    - meta_scope: string.quoted.double.c++
    - match: '\\.'
      scope: constant.character.escape.c++
    - match: '"'
      scope: punctuation.definition.string.end.c++
      pop: true

  line_comment:
    - meta_scope: comment.line.c++
    - match: $
      pop: true

  block_comment:
    - meta_scope: comment.block.c++
    - match: '\*/'
      scope: punctuation.definition.comment.c++
      pop: true

# generic handling of preprocessor
  preprocessor:
    - meta_scope: keyword.control.import.c++
    - include: common
    - match: <
      scope: punctuation.definition.generic.begin.c++
      push:
        - meta_scope: string.quoted.other
        - match: '>'
          scope: punctuation.definition.generic.end.c++
          pop: true
    - match: $
      pop: true

# after namespace keyword, find name of namespace if it exists
  namespace_name:
    - match: \w
      push:
        - meta_scope: entity.name.namespace.c++
        - match: \b
          pop: true
    - match: '{'
      pop: true

# after opening parenthesis, this finds params
  function_params:
    - match: '\)'
      set:
        - match: \bconst\b
          scope: storage.modifier.c++
        - match: ;
          pop: true
        - match: '{'
          set: function_body
    - match: \bconst\b
      scope: storage.modifier.c++
    - include: common
    - match: \b{{name}}\b
      scope: storage.type.c++
      set:
        - match: \b{{name}}\b
          scope: variable.parameter.c++
          set: function_params

  possible_const_variable_or_function:
    # if we find a *, then the const is part of the type, e.g.
    # char const* str = "xyz";
    # str is not actually const, it's a non const ptr to const char
    - match: '\*'
      set: variable_or_function
    - match: \b(static|inline|const|extern)\b
      scope: storage.modifier.c++
    - match: '\b{{name}}(?=\s*\()'
      scope: entity.name.function.c++
      set: after_function_name
    - match: \b{{name}}\b
      scope: variable.other.constant.c++
      pop: true

  after_function_name:
    - match: '\('
      set: function_params

  variable_or_function:
    - match: \bconst\b
      scope: storage.modifier.c++
      set: possible_const_variable_or_function
    - match: \b(static|inline|const|extern)\b
      scope: storage.modifier.c++
    - match: '\b{{name}}(?=\s*\()'
      scope: entity.name.function.c++
      set: after_function_name
    - match: \b{{name}}\b
      scope: variable.other.readwrite.c++
      pop: true

  function_body:
    - meta_scope: function

    - match: '{'
      push: function_body

    - match: '}'
      pop: true

    - include: common

    - match: \bif\b
      scope: keyword.control.conditional.c++

    - match: \breturn\b
      scope: keyword.control.c++

    - match: \bconst\b
      scope: storage.modifier.c++

    - match: \b{{name}}\b(?=\s*[;=\)\|\.-])
      scope: variable.other.c++

    - match: \b{{name}}\b(?=\s*\()
      scope: variable.function.c++

    - match: '\b{{name}}(?=::)'
      scope: storage.type.c++

    - match: \b{{type_name}}\b
      scope: storage.type.c++

    - match: '(->|\.|::)'
      scope: punctuation.accessor.c++

    - match: (==|\|\||&&|<=|>=|<|>|!=)
      scope: keyword.operator.logical.c++

    - match: =
      scope: keyword.operator.assignment.c++

    - match: (&|\||!|\^)
      scope: keyword.operator.bitwise.c++

    - match: (\+|-|\*|\\)
      scope: keyword.operator.arithmetic.c++

  function_params_in_func:
    - meta_content_scope: function_params
    - match: '\)'
      pop: true
    - match: '\('
      push: function_params_in_func
    - include: common
    - match: '\b{{type_name}}(?=::\w*\()'
      scope: storage.type.c++
      push:
        - match: \b{{name}}\b
          scope: variable.function.c++
          set:
            - match: '\('
              set: function_params_in_func
    - match: \b{{name}}\b(?=\s*\()
      scope: variable.function.c++
    - match: \b{{name}}\b
      scope: variable.other.c++

  possible_const_variable_in_func:
    # if we find a *, then the const is part of the type, e.g.
    # char const* str = "xyz";
    # str is not actually const, it's a non const ptr to const char
    - match: '\*'
      set: variable_in_func
    - match: \b(static|inline|const|extern)\b
      scope: storage.modifier.c++
    - match: \b{{name}}\b
      scope: variable.other.constant.c++
      pop: true

  variable_in_func:
    - match: \bconst\b
      scope: storage.modifier.c++
      set: possible_const_variable_or_function
    - match: \b(static|inline|const|extern)\b
      scope: storage.modifier.c++
    - match: \b{{name}}\b
      scope: variable.other.readwrite.c++
      pop: true